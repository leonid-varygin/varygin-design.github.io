class Dropdown {
    constructor(selector, options) { //1. создаём новый класс
        this.$el = document.querySelector(selector) //2. Заводим приватную переменную this.$el
        this.items = options.items //8. чтобы получить доступ во всём классе до элементов, которые передаем в dropdown
        //6. Нам надо засунуть элементы в список

        this.$el.querySelector('.dropdown__label').textContent = this.items[0].label //7. ищем элемент с классом дропдаун лейбл и с помощью textcontent сохраним значение первого элемента массива и забираем его свойство label
        
        //9. Заставим элемент отображать выпадающий список по клику
        this.$el.addEventListener('click', event => {  //10. Добавляем Евентлистенер на весь объект, а дальше уже будем понимать по какому элементу сделан клик
            if (event.target.classList.contains('dropdown__label')) { //11. Если мы сделали клик по элементу, у которого есть класс dropdown label, то это значит мы сделали клик непосредственно по нашему лейблу
                //12. Дальше необходимо либо открыть, либо закрыть dropdown
                if (this.$el.classList.contains('open')) { //13. Спрашиваем, если у this.$el есть класс open(если элемент открыт)
                    this.close() //14. Тогда мы его закрываем
                } else {
                    this.open() //15. Иначе, мы его открываем, с помощью метода open
                } //По идее, можно упростить это тернарным выражением. Но для наглядности оставлю так.
            } else if (event.target.tagName.toLowerCase() === 'li') {// 22. Если у нас нет у блока класса dropdown label, то тогда мы можем проверить: если элемент является элементом Li, приведём его в строку в нижнем регистре (чтобы наверняка знать, что там нет разного регистра) и проверим на строгое соответствие li
                this.select(event.target.dataset.id)
                
            }   
        })  

        //16. Добавляем возможность отображаться остальным элементам списка

        //18. создадим переменную itemsHTML
        const itemsHTML = this.items.map(i => { //19. так как Items это массив, то есть метод map, который может преобразовывать каждый элемент массива и на каждой итерации мы будем получать некоторый i (item)
            return `<li data-id="${i.id}">${i.label}</li>` //20. на каждой итерации формируем тег ли, у которого будет i.label
        }).join(' ') //21. Так как метод map возвращает массив, нам надо привести его к строке через метод join. Указываю пробел, чтобы в будущем наш HTML соединился как строка через пробел
        //17. Нам необходимо найти выпадающий список

        this.$el.querySelector('.dropdown__menu').insertAdjacentHTML('beforeend', itemsHTML) //18. Находим список по классу .dropdown__menu и с помощью функции .insertAdjacentHTML добавляем некоторый код после дочернего элемента в дерево DOM

    } 

    select(id) {
        const item = this.items.find(i => i.id === id) //19. Далее делаем проверку, где ищем соответствие данным массива
        this.$el.querySelector('.dropdown__label').textContent = item.label //20.Меняем название лейбла на выбранный из списка
        this.close() //21. Добавляем для того, чтобы закрыть dropdown
        
    }
        //3. оживляем плагин при помощи двух публичных методов
    open() { //открывает дропдаун
        this.$el.classList.add('open') //4. Добавляем класс open к дропдауну
    }

    close() { //закрывает дропдаун
        this.$el.classList.remove('open') //5. Удаляем класс open от дропдауна, чтобы спрятать элемент
    }
}


const dropdown = new Dropdown('#dropdown', { //инициализируем новый класс
    items: [
      {label: 'Москва', id: 'msk'},
      {label: 'Санкт-Петербург', id: 'spb'},
      {label: 'Новосибирск', id: 'nsk'},
      {label: 'Кемерово', id: 'kemr'},
      {label: 'говноМариинск', id: 'mrsk'},
      {label: 'Надька пизда', id: 'nkpz'}
    ]
  })